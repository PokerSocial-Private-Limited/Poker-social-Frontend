#!/usr/bin/env node
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var commander = _interopRequireWildcard(require("commander"));

var fse = _interopRequireWildcard(require("fs-extra"));

var reactNativeSvgAppIcon = _interopRequireWildcard(require("./index"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const supportedPlatforms = ["android", "ios"];
/**
 * Default values for CLI configuration. Custom values are merged on top.
 */

const defaultConfig = {
  backgroundPath: "./icon-background.svg",
  foregroundPath: "./icon.svg",
  platforms: supportedPlatforms,
  force: false,
  androidOutputPath: "./android/app/src/main/res"
};

async function main(args = []) {
  console.log("Running react-native-svg-app-icon");
  const cliConfig = { ...defaultConfig,
    ...(await readFileConfig()),
    ...readArgsConfig(args)
  };

  if (!(await fse.pathExists(cliConfig.foregroundPath))) {
    throw Error(`Icon is required, but not found at ${cliConfig.foregroundPath}`);
  }

  cliConfig.platforms = cliConfig.platforms.map(platform => platform.toLowerCase()).filter(platform => {
    if (supportedPlatforms.includes(platform)) {
      return true;
    } else {
      throw Error(`Unsupported platform ${platform}`);
    }
  });
  const generatedFiles = reactNativeSvgAppIcon.generate({
    icon: {
      backgroundPath: (await fse.pathExists(cliConfig.backgroundPath)) ? cliConfig.backgroundPath : undefined,
      foregroundPath: cliConfig.foregroundPath
    },
    platforms: cliConfig.platforms,
    force: cliConfig.force,
    androidOutputPath: cliConfig.androidOutputPath,
    iosOutputPath: cliConfig.iosOutputPath
  });

  for await (const file of generatedFiles) {
    console.log("Wrote " + file);
  }

  console.log("Done");
}

async function readFileConfig() {
  try {
    const appJson = await fse.readJson("./app.json");
    return appJson.svgAppIcon || {};
  } catch (error) {
    return {};
  }
}

function readArgsConfig(args) {
  const program = new commander.Command();
  program.name("react-native-svg-app-icon").option("--background-path <path>", "background icon path").option("--foreground-path <path>", "foreground icon path").option("--platforms <platforms...>", "platforms for which to generate icons").option("-f, --force", "overwrite existing newer files").option("--android-output-path <path>", "android output path").option("--ios-output-path <path>", "ios output path").parse(args);
  return program.opts();
}

if (require.main === module) {
  main(process.argv).catch(error => {
    console.error(error);
    process.exit(1);
  });
}

var _default = main;
exports.default = _default;